/*
 * This file is part of the ProVANT simulator project.
 * Licensed under the terms of the MIT open source license. More details at
 * https://github.com/Guiraffo/ProVANT-Simulator/blob/master/LICENSE.md
 */
/**
 * @file This file contains the implementation of the LQRQuadcopter class.
 *
 * @author Jonatan Campos
 */

#include <control_strategies_base/icontroller.hpp>
#include <Eigen/Eigen>
#include "simulator_msgs/Sensor.h"
#include <ros/ros.h>

static const int NINPUTS = 4;
static const int NSTATES = 12;

/**
 * @brief The LQRQuadcopter implements a Linear Quadratic Regulator control
 * strategy for the quadrotor UAV that is available in the ProVANT simulator.
 *
 * This controller uses a helicoidal reference trajectory.
 *
 * This control strategy expects a state vector composed of the generalized
 * coordinates and their derivatives in the following order:
 * [x y z phi theta psi x_dot y_dot z_dot phi_dot theta_dot psi_dot]
 *
 * x, y and z are the cartesian coordinates of the UAV center of rotation in
 * relation with the inertial reference frame and expressed in meters,
 * phi is the rotation around the x axis, theta is the rotation around the y
 * axis and psi is the rotation around the z axis, all of the angles of rotation
 * are expressed in radians.
 *
 * x_dot, y_dot and z_dot are the time derivatives of the cartesian coordinates,
 * that equal the linear velocities of the UAV in relation with the inertial
 * frame. The values are given in m/s.
 *
 * Finally, phi_dot, theta_dot and psi_dot are the time derivatives of the Euler
 * Angles, given in rad/s.
 *
 * The control inputs of this system are the forces generated by each propeller
 * in the order f1, f2, f3 and f4, where fi is the force of the i-th propeller.
 * All of the forces are expressed in Newtons.
 *
 */
class LQRQuadcopter : public Icontroller
{
private:
  //! Stores the reference vector
  Eigen::VectorXd Xref;
  //! Stores the error vector
  Eigen::VectorXd Erro;
  //! Stores the control inputs
  Eigen::VectorXd Input;
  //! Stores the gain matrix of the system
  Eigen::MatrixXd K;
  //! Stores the state vector
  Eigen::VectorXd X;

public:
  /**
   * @brief Construct a new LQRQuadcopter object and initialize the size of
   * the matrices used in the controller.
   */
  LQRQuadcopter() : Xref(NSTATES), K(NINPUTS, NSTATES), X(NSTATES), Erro(NSTATES), Input(NINPUTS)
  {
    config();
  }

  /**
   * @brief Destroy the LQRQuadcopter object.
   */
  virtual ~LQRQuadcopter()
  {
  }

  /**
   * @brief Initialize the gain matrix K.
   */
  void config()
  {
    K << -70.711, 2.1302e-11, 7.0711, -2.3813e-12, -156.46, 5, -165.1, 4.7388e-11, 11.53, 8.2065e-13, -7.5435, 5.7987,
        1.3204e-11, -70.711, 7.0711, 156.46, 8.257e-11, -5, 3.1756e-11, -165.1, 11.53, 7.5435, 8.1385e-12, -5.7987,
        70.711, 3.9104e-11, 7.0711, -4.7265e-11, 156.46, 5, 165.1, 8.9701e-11, 11.53, 9.2039e-13, 7.5435, 5.7987,
        -5.6384e-12, 70.711, 7.0711, -156.46, 6.4636e-11, -5, -8.3103e-12, 165.1, 11.53, -7.5435, 8.4109e-12, -5.7987;
  }

  /**
   * @brief Execute the LQR control law.
   *
   * This method is called every simulation step.
   * It is responsible for reading the state vector from the arraymsg,
   * calculating the reference trajectory, the error vector, and must return
   * the control inputs to be applied on the system.
   *
   * @param arraymsg Array of simulator messages containing the sensors
   * of the quadrotor model. In this case, the only sensor is the state vector.
   * @returns Control inputs vector to be applied on the system. See the
   * class documentation for more details.
   */
  std::vector<double> execute(simulator_msgs::SensorArray arraymsg)
  {
    // Search for the state vector in the recevied messages
    simulator_msgs::Sensor msg;
    bool found = false;
    for (int i = 0; i < arraymsg.values.size(); i++)
    {
      if (arraymsg.values.at(i).name == "Estados")
      {
        msg = arraymsg.values.at(i);
        found = true;
        break;
      }
    }
    if (!found)
    {
      // In case of error, report the problem in a ROS_LOG, and returns an
      // empty array
      ROS_FATAL("[lqr_quadcopter] State vector not found.");
      std::vector<double> out(Input.data(), Input.data() + Input.size());
      return out;
    }

    // Get the current simulation time and calculate the reference trajectory.
    ros::Time time = ros::Time::now();
    double tempo = time.toSec();

    Xref << sin(tempo / 2), cos(tempo / 2), tempo / 10, 0, 0, 0, 0, 0, 0, 0, 0, 0;

    // Read the values of the state vector from the message
    X << msg.values.at(0),  // x
        msg.values.at(1),   // y
        msg.values.at(2),   // z
        msg.values.at(3),   // roll
        msg.values.at(4),   // pitch
        msg.values.at(5),   // yaw
        msg.values.at(6),   // x_dot
        msg.values.at(7),   // y_dot
        msg.values.at(8),   // z_dot
        msg.values.at(9),   // roll_dot
        msg.values.at(10),  // pitch_dot
        msg.values.at(11);  // yaw_dot

    // Calculate the error vector of the system
    Erro = X - Xref;

    // Execute the control law (Multiply the gain matrix by the error vector)
    Input = -K * Erro;

    // Add equilibirium forces to the outputs.

    Input(0) = Input(0) + 5.77611;
    Input(1) = Input(1) + 5.77611;
    Input(2) = Input(2) + 5.77611;
    Input(3) = Input(3) + 5.77611;

    ROS_DEBUG_STREAM_NAMED("lqr_quadcopter", "[LQRQuadcopter]: F1: " << Input(0));
    ROS_DEBUG_STREAM_NAMED("lqr_quadcopter", "[LQRQuadcopter]: F2: " << Input(1));
    ROS_DEBUG_STREAM_NAMED("lqr_quadcopter", "[LQRQuadcopter]: F3: " << Input(2));
    ROS_DEBUG_STREAM_NAMED("lqr_quadcopter", "[LQRQuadcopter]: F4: " << Input(3));
    
    // Copy the control inputs values to the output vector
    std::vector<double> out(Input.data(), Input.data() + Input.size());
    return out;
  }

  /**
   * @brief Reference()
   *
   * This method is called by the logging functions to report the
   * reference values for the current step.
   *
   * @returns Reference vector for the current step. This vector is in the same
   * order of the state vector.
   */
  std::vector<double> Reference()
  {
    // Copy the references to a std::vector
    std::vector<double> out(Xref.data(), Xref.data() + Xref.rows() * Xref.cols());
    return out;
  }

  /**
   * @brief Error()
   *
   * This method is called by the logging functions to get the error vector
   * used in the control law execution.
   *
   * @returns The error vector of the system in the current step. The error
   * vector is in the same order of the state vector.
   */
  std::vector<double> Error()
  {
    // Copy the references to a std::vector
    std::vector<double> out(Erro.data(), Erro.data() + Erro.rows() * Erro.cols());
    return out;
  }

  /**
   * @brief State()
   *
   * This method is called by the logging functions to get the state vector
   * used in the control law execution.
   * Note that if the implmeneted controller uses an augmented state vector,
   * for example, with integral sates, these values should also be returned
   * by this function.
   *
   * @returns The state vector of the system used in the calculation of the
   * control law in the current step time. This vector is in the same order
   * as the states vector.
   */
  std::vector<double> State()
  {
    std::vector<double> out(X.data(), X.data() + X.rows() * X.cols());
    return out;
  }
};

// Functions used by the ProVANT Simulator to instantiate this control law
extern "C" {
Icontroller* create(void)
{
  return new LQRQuadcopter;
}
void destroy(Icontroller* p)
{
  delete p;
}
}
