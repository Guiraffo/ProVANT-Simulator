/*
 * This file is part of the ProVANT simulator project.
 * Licensed under the terms of the MIT open source license. More details at
 * https://github.com/Guiraffo/ProVANT-Simulator/blob/master/LICENSE.md
 */
/**
 * \file This file contains the declaration of the ControllerNode class.
 *
 * @author Arthur Viana Lara
 * @author JÃºnio Eduardo de Morais Aquino
 */

#ifndef CONTROLLER_H
#define CONTROLLER_H

#include <list>
#include <map>
#include <mutex>
#include <string>
#include <vector>
#include "ros/ros.h"
#include "std_msgs/Float64.h"
#include "std_msgs/String.h"
#include "controller/MatlabData.h"
#include "simulator_msgs/Sensor.h"
#include "simulator_msgs/SensorArray.h"
#include "std_srvs/SetBool.h"
#include "control_strategies_base/icontroller.hpp"
#include <provant_simulator_xml_reader/config_reader.h>

class ControllerNode
{
public:
  /**
   * @brief Initializes ROS.
   *
   * @param argc Number of arguments received by the program.
   * @param argv List of arugments recevied by the program.
   */
  static void init(int argc, char** argv);

  /**
   * @brief Construct a new Controller Node object.
   */
  ControllerNode(std::string configFilePath);

  /**
   * @brief Destroy the Controller Node object and release the handles to the
   * DLLs.
   */
  virtual ~ControllerNode();

private:
  /**
   * @brief Stores the path to the configuration file for this simulation.
   */
  std::string _configFilePath;

  /**
   * @brief XML file containing the configuration of this simulation.
   *
   * This object is used to read the value of the XML tags containing the
   * desired parameters for the simulation, such as the control law execution
   * ratio, path to the log files, and the desired control strategy.
   */
  ConfigReader configFile;

  /**
   * @brief Handle for the ROS node.
   */
  ros::NodeHandle nh;

  /**
   * @brief Store the ROS publishers for the topics of the actuators.
   *
   * @todo Convert this to a std::list after the refactoring of the XMLRead
   * class.
   */
  std::vector<ros::Publisher> actuatorPublishersArray;

  /**
   * @brief Stores the list of ROS subscribers to the topics of the sensors.
   *
   * OBS: Storing the references to the subscribers is necessary because ROS
   * remvoes the subscription as soon as a subscriber object goes out of scope.
   *
   * @todo Convert this to a std::list after the refactoring of the XMLRead
   * class.
   */
  std::vector<ros::Subscriber> sensorSubscribers;

  /**
   * @brief This value determines how many steps must pass before a new
   * execution of the control law.
   *
   * For example, for a controlLawExecutionRatio with value 10, the control law
   * will only be executed once at every 10 steps.
   *
   * For a controlLawExecutionRatio with value 12, the control law will only
   * be executed once at every 12 steps, and os for.
   */
  int controlLawExecutionRatio;

  /**
   * @brief Counter that stores the number of steps during each execution cyle.
   *
   * This counter is used to determine when the control law must be executed
   * in order ot update the control input values.
   */
  int stepCounter;

  /**
   * @brief Name of the control strategy library executed in this node.
   */
  std::string controlStrategy;

  /**
   * @brief Map from the name of a sensor to the index in the sensor array
   * passed to the control law.
   *
   * This variable is necessary to ensure that the order of the sensors
   * is always the same in the message sent to the control law execute
   * method.
   */
  std::map<std::string, int> sensorIndexMap;

  /**
   * @brief Counter that stores the number of updated states during each step
   * time.
   */
  int sensorCounter;

  /**
   * @brief File to log the control inputs generated by the control law.
   */
  MatlabData controlInputsLog;

  /**
   * @brief File to log the value of the model states.
   */
  MatlabData stateLog;

  /**
   * @brief File to log the reference values.
   */
  MatlabData referenceLog;

  /**
   * @brief File to log the tracking error values.
   */
  MatlabData trackingErrorLog;

  /**
   * @brief Mutex used by the states update callback.
   */
  std::mutex _mutex;

  /**
   * @brief Stores the last values of the control inputs generated by the
   * control law.
   */
  std::vector<double> controlInputs;

  /**
   * @brief Stores the data of the sensors received from the Gazebo simulator
   * during the last sampling period.
   */
  simulator_msgs::SensorArray sensorData;

  /**
   * @brief ROS topic to advance one simulation step in gazebo.
   */
  ros::Publisher stepPublisher;

  /**
   * @brief ROS publisher to the /provant_simulator/simulation_state topic.
   */
  ros::Publisher simulationStatePublisher;

  /**
   * @brief Handle to the instance of the dynamicly loaded library that contains
   * the instance of the control strategy.
   */
  void* dllHandle = NULL;

  /**
   * @brief Instance of the control strategy executed by this node.
   */
  Icontroller* controller = NULL;

  /**
   * @brief Indicates if the controller must automatically advance another step
   * at the end of the calculation of the control law for the current step.
   */
  bool autoStepEnabled = false;

  /**
   * @brief ROS Service that allows enabling or disabling the auto stepping
   * mode.
   * @sa autoStepEnabled
   */
  ros::ServiceServer autoSteppingServer;

  /**
   * @brief Number of steps the simulation must be executed for.
   * A zero value indicates that the simulation is user controlled, and must not
   * be automattically terminated by the controller node.
   */
  uint64_t _simulationDuration;

  /**
   * @brief Indicates if the node must shutdown when the simulation is finished.
   */
  bool _closeWhenFinished;

  /**
   * @brief Message used to identify this node in log messages printed to the
   * output screen.
   */
  std::string _logMsg = "[ControllerNode] ";

  /**
   * @brief Counter the number of simulation steps.
   */
  unsigned int _totalStepCounter = 0;

  /**
   * @brief Indicates if the simulation must be started in a paused state or
   * not.
   */
  bool _startPaused = true;

  /**
   * @brief Indicates if the simulation was already started or not.
   */
  bool _started = false;
 
 /** 
  *@brief Indicates if the simulation is hil synchronous or not.
  */
  bool _hilSync = false;

 /** 
  *@brief Indicates if the simulation is hil asynchronous or not.
  */
  bool _hilAsync = false;

  /**
   * @brief Mutex used to update the value of the _started variable.
   */
  std::mutex _startedMutex;

  /**
   * @brief Advance one step in the simulation.
   *
   * This method publishes a message in the step topic, that has the function
   * to inform gazebo that the simulation must be advanced in one step, with
   * duration equal to the configured sample time.
   */
  void step();

  /**
   * @brief Creates and initializes an instance of the control strategy dynamic
   * library.
   *
   * This method constructs an instance of the control strategy DLL, and the
   * create function contained in the DLL, stores their handles, and
   * initializes an instance of the control strategy control loop.
   *
   * If an error is encountered at any step, an appropriate log message is
   * sent and an the execution of the node is halted with a failure status.
   */
  void setupControlStrategy();

  /**
   * @brief Create and verify the dat files for the simulation log.
   *
   * This method create the files for the logs of the references, states,
   * tracking error and applied control inputs generated during the simulation.
   *
   * The methods also verify that all of the files were successfully open and
   * emits appropriate log messages and halts the node execution with a failure
   * status otherwise.
   */
  void setupLogging();

  /**
   * @brief Callback method called when a sensor message is received by the
   * node.
   *
   * This function checks if a sensor with a valid name was configured in the
   * sensor list of the config.xml file, and inserts it under the appropriate
   * index of a SensorArray message that is passes to the control strategy.
   *
   * If a sensor with a unrecognized name is recevied, an appropriate log
   * message is emitted.
   *
   * @param msg
   */
  void stateUpdateCallback(simulator_msgs::Sensor msg);

  /**
   * @brief Method that executes the control law and apply the resulting control
   * inputs to the actuators.
   *
   * To enhance the value read from the sensors during the simulation, the
   * control law is only executed once at each execution cycle.
   *
   * The execution cycle is a positive integer value set by the
   * controlLawExecutionRatio member variable, for more details about this see
   * the documentation of this variable.
   *
   * After executing the control law, the control inputs are updated and sent
   * to configured topic for each actuator.
   */
  void controlLaw();

  /**
   * @brief Configures the ROS node, subscribe to the nodes to receive updates
   * from the sensor and the publishers to update the control input values.
   *
   * This method performs the initialization fo the ROS node and reads the
   * parameters from the config.xml file indiating what the selected control
   * strategy is, and what is the value for the controlLawExecutionRatio.
   */
  void setupNode();

  /**
   * @brief Service handler for the ROS enable_autostepping service.
   *
   * This service allows enabling or disabling the autostepping mode, i.e.
   * it determines if the next should be initiated at the end of the current
   * control law calculation.
   *
   * @param req Request data for the service.
   * @param res Response data from the service.
   * @return True if the service call was handled successfully and false
   * otherwise.
   */
  bool setAutostepping(std_srvs::SetBool::Request& req, std_srvs::SetBool::Response& res);

  /**
   * @brief Called when the simulation finishes.
   * 
   * Close all the files, and closes this node.
   */
  void shutdown();

  /**
   * @brief Method called when a subscriber connects to the the step topic.
   * 
   * If the simulation must be automatically started by the controller node
   * this method will be called when the first subscriber connects to the 
   * /Step topic.
   * 
   * In this first call the method must then send an initial step to start the
   * simulation. 
   */
  void onStepSubscriberConnect();

  /**
   * @brief Helper method to publish the simulation state.
   * 
   * @param state Simulation state to publish.
   */
  void publishSimulationState(const std::string& state);
};

#endif  // CONTROLLER_H
