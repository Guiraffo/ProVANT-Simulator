\chapter{package.xml}
\label{package}

Esta seção possui conteúdo retirado da página \url{http://wiki.ros.org/catkin/package.xml} no dia 25/08/2017. Para mais detalhes, visite-a.

\section{Visão geral}

O manifesto do pacote é um arquivo XML chamado package.xml que deve ser incluído no diretório raíz de qualquer pacote compatível com catkin. Este arquivo define propriedades sobre o pacote, como o nome do pacote, números de versão, autores, responsáveis e dependências em outros pacotes catkin.

As dependências do pacote do sistema são declaradas em package.xml. Se eles estão faltando ou incorretos, é possível criar a partir da fonte e executar testes em sua própria máquina, mas o pacote não funcionará corretamente quando for lançado para a comunidade ROS. Outros dependem dessas informações para instalar o software necessário para usar seu pacote.

\section{Formato 2 (Recomendado)}

Este é o formato recomendado para novos pacotes. Também é recomendado que os pacotes anteriores do formato 1 sejam migrados para o formato 2. Para obter instruções sobre como migrar do formato 1 para o formato 2, consulte a página \url{http://docs.ros.org/indigo/api/catkin/html/howto/format2/migrating_from_format_1.html#migrating-from-format1-to-format2} para mais informações.

A documentação completa para o formato 2 pode ser encontrada em \url{http://www.ros.org/reps/rep-0140.html}. 

\subsection{Estrutura básica}

Cada arquivo package.xml tem uma tag <package> como tag raíz do documento.

\begin{minted}{xml}
<package format="2">

</package>
\end{minted}

\subsection{Tags requisitadas}

Há um conjunto mínimo de tags que necessitam de ser alocadas dentro da tag <package> para tornar o manifesto do pacote completo.

\begin{itemize}
	\setlength{\itemsep}{1pt}
	\setlength{\parskip}{0pt}
	\setlength{\parsep}{0pt}
	\item[] <name> - O nome do pacote
	\item[] <version> - O número da versão do pacote (obrigatório ter 3 inteiros separados por pontos)
	\item[] <description> - Descrição do conteúdo do pacote
	\item[] <maintainer> - Nome das pessoas que realizam a manutençaõ do pacote
	\item[] <license> - A(s) licença(s) de software (por exemplo, GPL, BSD, ASL) sob a qual o código é liberado.
\end{itemize}


Observe um exemplo de manifesto para um pacote fictício denominado foo\_core.

\begin{minted}{xml}
<package format="2">
	<name>foo_core</name>
	<version>1.2.4</version>
	<description>
		This package provides foo capability.
	</description>
	<maintainer email="ivana@osrf.org">Ivana Bildbotz</maintainer>
	<license>BSD</license>
</package>
\end{minted}

\subsection{Dependências}

O manifesto do pacote com tags mínimas não especifica nenhuma dependência em outros pacotes. Os pacotes podem ter seis tipos de dependências:

\begin{itemize}
	\setlength{\itemsep}{1pt}
	\setlength{\parskip}{0pt}
	\setlength{\parsep}{0pt}
	\item \textbf{Dependências de compilação} especifica quais pacotes são necessários para compilar este pacote. Este é o caso quando algum arquivo destes pacotes é requisitado em tempo de compilação. Isto pode ser realizado incluindo cabeçalhos destes pacotes em tempo de compilação, ligando bibliotecas destes pacotes ou requisitando algum outro recurso em tempo de compilação (especialmente quando estes pacotes são encontrados por find\_package() no CMake). Num cenário de cross-compilação construir dependências são próprias para uma arquitetura segmentada.
	\item \textbf{Dependências de exportação} 
	especifica quais pacotes são necessários para criar bibliotecas. Este é o caso quando você inclui indiretamente seus cabeçalhos em cabeçalhos públicos neste pacote (especialmente quando estes pacotes são declarados como (CATKIN\_)DEPENDs em catkin\_package() no CMake).
	\item \textbf{Dependências de execução} 
	Especifica quais pacotes são necessários para executar o código neste pacote. Este é o caso quando você depende de bibliotecas compartilhadas neste pacote (especialmente quando esses pacotes são declarados como (CATKIN\_)DEPENDs em catkin\_package() no CMake).
	\item \textbf{Dependências de testes} 
	Especifica apenas dependências adicionais para testes unitários. Nunca devem duplicar quaisquer dependências já mencionadas como dependências de compilação ou execução.
	\item \textbf{Dependências de ferramentas de construção} Especifica as ferramentas do sistema de compilação que este pacote precisa construir. Normalmente, a única ferramenta de compilação necessária é o sistema catkin. Em um cenário de compilação cruzada, as dependências da ferramenta de compilação são para a arquitetura na qual a compilação é executada.
	\item \textbf{Dependências de ferramentas de documentação} especifica ferramentas que esse pacote precisa para gerar documentação.
\end{itemize}

Esses seis tipos de dependências são especificados usando as seguintes tags respectivas:

\begin{itemize}
	\setlength{\itemsep}{1pt}
	\setlength{\parskip}{0pt}
	\setlength{\parsep}{0pt}
	\item []<depend> especifica uma dependência de compilação, exportação e execução. Esta é a etiqueta de dependência mais usada.
	\item []<buildtool\_depend>
	\item []<build\_depend>
	\item []<build\_export\_depend>
	\item []<exec\_depend>
	\item []<test\_depend>
	\item []<doc\_depend>
\end{itemize}

Todos os pacotes possuem pelo menos uma dependência. A seguir está um exemplo de uma dependência de ferramenta de compilação no sistema catkin.

\begin{minted}{xml}
<package>
	<name>foo_core</name>
	<version>1.2.4</version>
	<description>
		This package provides foo capability.
	</description>
	<maintainer email="ivana@osrf.org">Ivana Bildbotz</maintainer>
	<license>BSD</license>
	<buildtool_depend>catkin</buildtool_depend>
</package>
\end{minted}

Um exemplo mais realista que especifica as dependências de compilação, exec, teste e doc pode parecer o seguinte.

\begin{minted}{xml}
<package>
	<name>foo_core</name>
	<version>1.2.4</version>
	<description>
		This package provides foo capability.
	</description>
	<maintainer email="ivana@willowgarage.com">Ivana Bildbotz</maintainer>
	<license>BSD</license>
	<url>http://ros.org/wiki/foo_core</url>
	<author>Ivana Bildbotz</author>
	<buildtool_depend>catkin</buildtool_depend>
	<depend>roscpp</depend>
	<depend>std_msgs</depend>
	<build_depend>message_generation</build_depend>
	<exec_depend>message_runtime</exec_depend>
	<exec_depend>rospy</exec_depend>
	<test_depend>python-mock</test_depend>
	<doc_depend>doxygen</doc_depend>
</package>
\end{minted}


\subsection{Metapackages}


Muitas vezes, é conveniente agrupar vários pacotes como um único pacote lógico. Isso pode ser obtido através de metapackages. Um metapackage é um pacote normal com a seguinte \textit{tag} de exportação no package.xml:

\begin{minted}{xml}
<export>
	<metapackage />
</export>
\end{minted}


Além de uma dependência <buildtool\_depends> necessária, os metapackages só podem ter dependências executadas em pacotes dos quais eles agrupam.

Além disso, um metapackage possui um arquivo CMakeLists.txt obrigatório:

\begin{minted}{xml}
cmake_minimum_required(VERSION 2.8.3)
project(<PACKAGE_NAME>)
find_package(catkin REQUIRED)
catkin_metapackage()\end{minted}

Note: substitua <PACKAGE\_NAME> com o nome do metapackage.

\subsection{Tags adicionais}

\begin{itemize}
	\setlength{\itemsep}{1pt}
	\setlength{\parskip}{0pt}
	\setlength{\parsep}{0pt}
	\item [] <url> - 
	Um URL para obter informações sobre o pacote, normalmente uma página do wiki no ros.org.
	\item [] <author> - O(s) autores do pacote
\end{itemize}

\section{Formato 1 (legado)}

Os pacotes catkin mais antigos usam o formato 1. Se a tag <package> não tiver um atributo de formato, é um pacote de formato 1. Use o formato 2 para novos pacotes.

\subsection{Estrutura básica}

Cada arquivo package.xml tem a tag <package> como tag raís no documento.

\begin{minted}{xml}
<package>

</package>
\end{minted}

\subsection{Tags Necessárias}

Há um conjunto mínimo de tags que precisam ser aninhadas dentro da tag <package> para tornar o pacote manifesto completo.

\begin{itemize}
	\setlength{\itemsep}{1pt}
	\setlength{\parskip}{0pt}
	\setlength{\parsep}{0pt}
	\item [] <name> - O nome do pacote
	\item []<version> - A versão do pacote (Obrigatório ter 3 inteiros separados por pontos)
	\item []<description> - Uma descrição do conteúdo do pacote
	\item []<maintainer> - O nome da pessoa responsáveis pela manutenção do pacote
	\item []<license> - A(s) licença(s) de software (por exemplo, GPL, BSD, ASL) sob a qual o código é liberado.
\end{itemize}


Como exemplo, aqui está o pacote manifesto para um pacote de ficção chamado foo\_core.


\begin{minted}{xml}
<package>
	<name>foo_core</name>
	<version>1.2.4</version>
	<description>
		This package provides foo capability.
	</description>
	<maintainer email="ivana@willowgarage.com">Ivana Bildbotz</maintainer>
	<license>BSD</license>
</package>
\end{minted}

\subsection{Dependências de compilação, execução e testes}

O manifesto do pacote com tags mínimas não especifica nenhuma dependência em outros pacotes. Pacotes podem ter quatro tipos de dependências:

\begin{itemize}
	\setlength{\itemsep}{1pt}
	\setlength{\parskip}{0pt}
	\setlength{\parsep}{0pt}
	\item \textbf{Dependências de ferramentas de construção} 
	especifica as ferramentas do sistema de compilação que este pacote precisa construir. Normalmente, a única ferramenta de compilação necessária é o sistema catkin. Em um cenário de compilação cruzada, as dependências da ferramenta de compilação são para a arquitetura na qual a compilação é executada.
	\item \textbf{Dependências de construção} especifica quais pacotes são necessários para criar este pacote. Este é o caso quando um arquivo desses pacotes é necessário no momento da compilação. Isso pode incluir cabeçalhos desses pacotes no momento da compilação, vinculando as bibliotecas desses pacotes ou exigindo qualquer outro recurso em tempo de compilação (especialmente quando esses pacotes são find\_package()-ed no CMake). Em um cenário de compilação cruzada, as dependências de compilação são para a arquitetura segmentada.
	\item \textbf{Dependências de execução} especifica quais pacotes são necessários para executar o código neste pacote ou criar bibliotecas neste pacote. Este é o caso quando você depende de bibliotecas compartilhadas ou inclui transitivamente seus cabeçalhos em cabeçalhos públicos (especialmente quando estes pacotes são declarados como (CATKIN\_)DEPENDs em catkin\_package() no CMake).
	\item \textbf{Dependências de teste} especifica apenas dependências adicionais para testes unitários. Eles nunca devem duplicar quaisquer dependências já mencionadas como dependências de compilação ou execução.
\end{itemize}

Esses quatro tipos de dependências são especificados usando as seguintes tags:

\begin{itemize}
	\setlength{\itemsep}{1pt}
	\setlength{\parskip}{0pt}
	\setlength{\parsep}{0pt}
	\item <buildtool\_depend>
	\item<build\_depend>
	\item<run\_depend>
	\item<test\_depend>
\end{itemize}

Todos os pacotes possuem pelo menos uma dependência de ferramenta de compilação no catkin conforme mostra o exemplo a seguir.

\begin{minted}{xml}
<package>
	<name>foo_core</name>
	<version>1.2.4</version>
	<description>
		This package provides foo capability.
	</description>
	<maintainer email="ivana@willowgarage.com">Ivana 	Bildbotz</maintainer>
	<license>BSD</license>
	<buildtool_depend>catkin</buildtool_depend>
</package>
\end{minted}

Um exemplo mais realista que especifica as dependências de compilação, tempo de execução e teste pode ser o seguinte.

\begin{minted}{xml}
<package>
	<name>foo_core</name>
	<version>1.2.4</version>
	<description>
		This package provides foo capability.
	</description>
	<maintainer email="ivana@willowgarage.com">Ivana Bildbotz</maintainer>
	<license>BSD</license>
	<url>http://ros.org/wiki/foo_core</url>
	<author>Ivana Bildbotz</author>
	<buildtool_depend>catkin</buildtool_depend>
	<build_depend>message_generation</build_depend>
	<build_depend>roscpp</build_depend>
	<build_depend>std_msgs</build_depend>
	<run_depend>message_runtime</run_depend>
	<run_depend>roscpp</run_depend>
	<run_depend>rospy</run_depend>
	<run_depend>std_msgs</run_depend>
	<test_depend>python-mock</test_depend>
</package>
\end{minted}


\subsection{Metapackages}

Muitas vezes, é conveniente agrupar vários pacotes como um único pacote lógico. Isso pode ser conseguido através de metapackages. Um metapackage é um pacote normal com a seguinte tag de exportação no package.xml:

\begin{minted}{xml}
<export>
	<metapackage />
</export>
\end{minted}


Além de uma dependência <buildtool\_depends> necessária, os metapackages só podem ter dependências executadas em pacotes dos quais eles agrupam.

Além disso, um metapackage possui um arquivo CMakeLists.txt obrigatório, exigido:

\begin{minted}{xml}
cmake_minimum_required(VERSION 2.8.3)
project(<PACKAGE_NAME>)
find_package(catkin REQUIRED)
catkin_metapackage()
\end{minted}

Note: substitua <PACKAGE\_NAME> com o nome do metapackage. 

\subsection{Tags Adicionais}

\begin{itemize}
	\setlength{\itemsep}{1pt}
	\setlength{\parskip}{0pt}
	\setlength{\parsep}{0pt}
	\item <url> - Um URL para obter informações sobre o pacote, normalmente uma página do wiki no ros.org.
	\item <author> - O(s) autor(es) do pacote 
\end{itemize}